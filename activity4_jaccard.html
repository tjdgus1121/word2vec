<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI í•µì‹¬ í‚¤ì›Œë“œ ê°ì„± ë¶„ì„ (Gemini)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700&display=swap');
        
        body {
            font-family: 'Noto Sans KR', sans-serif;
        }
        
        .morpheme-positive {
            background: linear-gradient(120deg, #fef08a 0%, #fef08a 100%);
            background-repeat: no-repeat;
            background-size: 100% 40%;
            background-position: 0 80%;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: 600;
            color: #059669;
        }
        
        .morpheme-negative {
            background: linear-gradient(120deg, #fecaca 0%, #fecaca 100%);
            background-repeat: no-repeat;
            background-size: 100% 40%;
            background-position: 0 80%;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: 600;
            color: #dc2626;
        }
        
        .morpheme-neutral {
            background: linear-gradient(120deg, #e0e7ff 0%, #e0e7ff 100%);
            background-repeat: no-repeat;
            background-size: 100% 40%;
            background-position: 0 80%;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: 600;
            color: #6366f1;
        }

        /* ì„¸ë¶€ ê°ì • ìŠ¤íƒ€ì¼ */
        .emotion-badge {
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 9999px;
            margin-left: 4px;
            font-weight: normal;
        }
        
        /* ë²¤ë‹¤ì´ì–´ê·¸ë¨ ë‹¨ì–´ ì• ë‹ˆë©”ì´ì…˜ */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        .word-hover {
            animation: fadeIn 0.3s ease-out;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .animate-spin {
            animation: spin 1s linear infinite;
        }
        
        .tooltip {
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .tooltip-trigger:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-slate-50 to-slate-100 dark:from-slate-900 dark:to-slate-800 min-h-screen transition-colors duration-300">
    <div class="container mx-auto px-4 py-8" style="max-width: 2304px;">
        <!-- Header -->
        <header class="mb-8">
            <div class="flex items-center justify-between mb-4">
                <div class="flex items-center gap-3">
                    <div class="w-12 h-12 bg-gradient-to-br from-violet-500 to-purple-600 rounded-2xl flex items-center justify-center shadow-lg">
                        <svg class="w-7 h-7 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
                        </svg>
                    </div>
                    <div>
                        <h1 class="text-3xl font-bold text-slate-800 dark:text-white">AI í•µì‹¬ í‚¤ì›Œë“œ ê°ì„± ë¶„ì„</h1>
                        <p class="text-sm text-slate-500 dark:text-slate-400 mt-1">Gemini API + ìì¹´ë“œ ìœ ì‚¬ë„ (ëª…ì‚¬/ìš©ì–¸ ì¶”ì¶œ)</p>
                    </div>
                </div>
                <div class="flex items-center gap-3">
                    <!-- Info Button -->
                    <div class="relative tooltip-trigger">
                        <button class="w-10 h-10 bg-white dark:bg-slate-700 rounded-xl shadow-md hover:shadow-lg transition-all flex items-center justify-center border border-slate-200 dark:border-slate-600">
                            <svg class="w-5 h-5 text-violet-600 dark:text-violet-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                        </button>
                        <div class="tooltip absolute right-0 mt-2 w-80 bg-white dark:bg-slate-700 rounded-2xl shadow-xl border border-slate-200 dark:border-slate-600 p-4 z-10">
                            <h3 class="font-semibold text-slate-800 dark:text-white mb-2">ğŸ¤– Gemini AI ë¶„ì„</h3>
                            <p class="text-sm text-slate-600 dark:text-slate-300 leading-relaxed mb-3">
                                Google Geminiê°€ ë¬¸ì¥ì—ì„œ ì˜ë¯¸ ìˆëŠ” í•µì‹¬ ë‹¨ì–´(ëª…ì‚¬, ë™ì‚¬, í˜•ìš©ì‚¬)ë¥¼ ì¶”ì¶œí•˜ê³  ê°ì„±ì„ ë¶„ì„í•©ë‹ˆë‹¤.
                            </p>
                            <div class="text-xs text-slate-500 dark:text-slate-400">
                                â€¢ í‚¤ì›Œë“œ ì¶”ì¶œ: ëª…ì‚¬, ìš©ì–¸ ìœ„ì£¼<br>
                                â€¢ ê°ì„± ë¶„ì„: ê¸ì •/ì¤‘ë¦½/ë¶€ì •<br>
                                â€¢ ìì¹´ë“œ ìœ ì‚¬ë„ ê³„ì‚°
                            </div>
                        </div>
                    </div>
                    <!-- Dark Mode Toggle -->
                    <button id="darkModeToggle" class="w-10 h-10 bg-white dark:bg-slate-700 rounded-xl shadow-md hover:shadow-lg transition-all flex items-center justify-center border border-slate-200 dark:border-slate-600">
                        <svg class="w-5 h-5 text-slate-600 dark:text-yellow-400 hidden dark:block" fill="currentColor" viewBox="0 0 20 20">
                            <path d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z"></path>
                        </svg>
                        <svg class="w-5 h-5 text-slate-600 dark:hidden" fill="currentColor" viewBox="0 0 20 20">
                            <path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path>
                        </svg>
                    </button>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <div class="space-y-8">
            <!-- 1í–‰: ì…ë ¥ + ì „ì²´ ìš”ì•½ + ê°ì„±ë‹¨ì–´ì‚¬ì „ -->
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                    <!-- ì…ë ¥ ì„¹ì…˜ -->
                    <div class="bg-white dark:bg-slate-800 rounded-2xl shadow-xl border border-slate-200 dark:border-slate-700 p-8">
                        <div class="flex items-center gap-2 mb-4">
                            <div class="w-8 h-8 bg-violet-100 dark:bg-violet-900/30 rounded-lg flex items-center justify-center">
                                <svg class="w-5 h-5 text-violet-600 dark:text-violet-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
                                </svg>
                            </div>
                            <h2 class="text-lg font-semibold text-slate-800 dark:text-white">í…ìŠ¤íŠ¸ ì…ë ¥</h2>
                        </div>
                        <textarea 
                            id="inputText" 
                            class="w-full h-56 p-4 border-2 border-slate-200 dark:border-slate-600 rounded-xl focus:border-violet-500 focus:ring-2 focus:ring-violet-200 dark:focus:ring-violet-800 outline-none resize-none text-slate-700 dark:text-slate-200 bg-slate-50 dark:bg-slate-900 transition-all"
                            placeholder="ë¶„ì„í•˜ê³  ì‹¶ì€ í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”. ì—¬ëŸ¬ ë¬¸ì¥ ì…ë ¥ ê°€ëŠ¥. (ìµœëŒ€ 300ì)"
                            maxlength="300"
                        ></textarea>
                        <div class="flex justify-end mt-1 mb-2">
                             <span id="charCount" class="text-sm text-slate-500 dark:text-slate-400">0 / 300</span>
                        </div>

                        <!-- Options -->
                        <div class="flex items-center gap-2 mb-4">
                            <input type="checkbox" id="detailAnalysisCheck" class="w-4 h-4 text-violet-600 bg-gray-100 border-gray-300 rounded focus:ring-violet-500 dark:focus:ring-violet-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
                            <label for="detailAnalysisCheck" class="text-sm font-medium text-gray-900 dark:text-gray-300">ì„¸ë¶€ ê°ì • ë¶„ì„</label>
                        </div>

                        <button 
                            id="analyzeBtn"
                            class="mt-4 w-full bg-gradient-to-r from-violet-600 to-purple-600 hover:from-violet-700 hover:to-purple-700 text-white font-semibold py-4 rounded-xl shadow-lg hover:shadow-xl transition-all transform hover:scale-105 active:scale-95"
                        >
                            <span class="flex items-center justify-center gap-2">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
                                </svg>
                                AI í‚¤ì›Œë“œ ë¶„ì„í•˜ê¸°
                            </span>
                        </button>
                    </div>

                    <!-- ì „ì²´ ìš”ì•½ ì„¹ì…˜ -->
                    <div id="resultsSection" class="bg-white dark:bg-slate-800 rounded-2xl shadow-xl border border-slate-200 dark:border-slate-700 p-8 hidden">
                        <div class="flex items-center gap-2 mb-4">
                            <div class="w-8 h-8 bg-violet-100 dark:bg-violet-900/30 rounded-lg flex items-center justify-center">
                                <svg class="w-5 h-5 text-violet-600 dark:text-violet-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                </svg>
                            </div>
                            <h2 class="text-lg font-semibold text-slate-800 dark:text-white">ì „ì²´ ìš”ì•½</h2>
                        </div>
                        
                        <!-- Sentiment Result -->
                        <div id="finalSentiment" class="p-4 rounded-xl text-center font-semibold text-lg mb-4"></div>

                        <!-- Formula Display -->
                        <div class="p-4 bg-slate-50 dark:bg-slate-900 rounded-xl">
                            <h3 class="text-sm font-semibold text-slate-600 dark:text-slate-400 mb-3 text-center">ğŸ“ ìì¹´ë“œ ìœ ì‚¬ë„</h3>
                            <div id="formulaDisplay" class="text-center text-slate-700 dark:text-slate-300 text-sm"></div>
                        </div>

                        <!-- Detailed Emotion Result (Optional) -->
                        <div id="detailEmotionResult" class="mt-4 p-4 bg-slate-50 dark:bg-slate-900 rounded-xl hidden">
                            <h3 class="text-sm font-semibold text-slate-600 dark:text-slate-400 mb-3 text-center">ğŸ“Š ì„¸ë¶€ ê°ì • ë¶„í¬</h3>
                            <div id="detailEmotionList" class="space-y-2 text-sm text-slate-700 dark:text-slate-300"></div>
                        </div>
                    </div>

                    <!-- ê°ì„±ë‹¨ì–´ì‚¬ì „ìœ¼ë¡œ ë¶„ì„ -->
                    <div id="dictionarySection" class="bg-white dark:bg-slate-800 rounded-2xl shadow-xl border border-slate-200 dark:border-slate-700 p-8 hidden">
                        <div class="flex items-center gap-2 mb-4">
                            <div class="w-8 h-8 bg-purple-100 dark:bg-purple-900/30 rounded-lg flex items-center justify-center">
                                <svg class="w-5 h-5 text-purple-600 dark:text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path>
                                </svg>
                            </div>
                            <h2 class="text-lg font-semibold text-slate-800 dark:text-white">ê°ì„±ì‚¬ì „</h2>
                        </div>
                        
                        <!-- ê¸ì • ë‹¨ì–´ -->
                        <div class="mb-3">
                            <div class="flex items-center gap-2 mb-2">
                                <span class="text-sm font-semibold text-emerald-700 dark:text-emerald-300">ğŸ˜Š ê¸ì •</span>
                                <span id="positiveWordCount" class="text-xs px-2 py-0.5 bg-emerald-100 dark:bg-emerald-900/30 text-emerald-700 dark:text-emerald-300 rounded-full font-bold">0ê°œ</span>
                            </div>
                            <div id="positiveWordsList" class="flex flex-wrap gap-2 p-3 bg-emerald-50 dark:bg-emerald-900/10 rounded-lg min-h-[50px] items-start text-xs">
                                <span class="text-slate-400">ë¶„ì„ ê²°ê³¼</span>
                            </div>
                        </div>

                        <!-- ì¤‘ë¦½ ë‹¨ì–´ -->
                        <div class="mb-3">
                            <div class="flex items-center gap-2 mb-2">
                                <span class="text-sm font-semibold text-indigo-700 dark:text-indigo-300">ğŸ˜ ì¤‘ë¦½</span>
                                <span id="neutralWordCount" class="text-xs px-2 py-0.5 bg-indigo-100 dark:bg-indigo-900/30 text-indigo-700 dark:text-indigo-300 rounded-full font-bold">0ê°œ</span>
                            </div>
                            <div id="neutralWordsList" class="flex flex-wrap gap-2 p-3 bg-indigo-50 dark:bg-indigo-900/10 rounded-lg min-h-[50px] items-start text-xs">
                                <span class="text-slate-400">ë¶„ì„ ê²°ê³¼</span>
                            </div>
                        </div>

                        <!-- ë¶€ì • ë‹¨ì–´ -->
                        <div class="mb-3">
                            <div class="flex items-center gap-2 mb-2">
                                <span class="text-sm font-semibold text-rose-700 dark:text-rose-300">ğŸ˜¢ ë¶€ì •</span>
                                <span id="negativeWordCount" class="text-xs px-2 py-0.5 bg-rose-100 dark:bg-rose-900/30 text-rose-700 dark:text-rose-300 rounded-full font-bold">0ê°œ</span>
                            </div>
                            <div id="negativeWordsList" class="flex flex-wrap gap-2 p-3 bg-rose-50 dark:bg-rose-900/10 rounded-lg min-h-[50px] items-start text-xs">
                                <span class="text-slate-400">ë¶„ì„ ê²°ê³¼</span>
                            </div>
                        </div>

                        <!-- êµì§‘í•© (ê¸ì • âˆ© ë¶€ì •) -->
                        <div class="mb-0">
                            <div class="flex items-center gap-2 mb-2">
                                <span class="text-sm font-semibold text-violet-700 dark:text-violet-300">ğŸ”„ êµì§‘í•©</span>
                                <span id="intersectionWordCount" class="text-xs px-2 py-0.5 bg-violet-100 dark:bg-violet-900/30 text-violet-700 dark:text-violet-300 rounded-full font-bold">0ê°œ</span>
                            </div>
                            <div id="intersectionWordsList" class="flex flex-wrap gap-2 p-3 bg-violet-50 dark:bg-violet-900/10 rounded-lg min-h-[50px] items-start text-xs">
                                <span class="text-slate-400">êµì§‘í•© ë‹¨ì–´</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 2í–‰: ë¬¸ì¥ë³„ ë¶„ì„ ê²°ê³¼ (ì „ì²´ ë„ˆë¹„) -->
                <div id="sentenceResultsSection" class="bg-white dark:bg-slate-800 rounded-2xl shadow-xl border border-slate-200 dark:border-slate-700 p-8 hidden">
                    <div class="flex items-center gap-2 mb-4">
                        <div class="w-8 h-8 bg-blue-100 dark:bg-blue-900/30 rounded-lg flex items-center justify-center">
                            <svg class="w-5 h-5 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path>
                            </svg>
                        </div>
                        <h2 class="text-lg font-semibold text-slate-800 dark:text-white">ë¬¸ì¥ë³„ ê°ì„± ë¶„ì„</h2>
                    </div>
                    <div id="sentenceResultsList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"></div>
                </div>

            <!-- ìˆ¨ê²¨ì§„ ì„¹ì…˜ë“¤ (ì‚¬ìš© ì•ˆ í•¨) -->
            <div id="morphemeSection" class="hidden"></div>
            <div id="vennSection" class="hidden"></div>
        </div>
    </div>

    <script>
        // DOM Elements
        const inputText = document.getElementById('inputText');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const morphemeSection = document.getElementById('morphemeSection');
        const morphemeDisplay = document.getElementById('morphemeDisplay');
        const vennSection = document.getElementById('vennSection');
        const dictionarySection = document.getElementById('dictionarySection');
        const sentenceResultsSection = document.getElementById('sentenceResultsSection');
        const resultsSection = document.getElementById('resultsSection');
        const darkModeToggle = document.getElementById('darkModeToggle');
        const charCount = document.getElementById('charCount');
        const detailAnalysisCheck = document.getElementById('detailAnalysisCheck');
        const detailEmotionResult = document.getElementById('detailEmotionResult');
        const detailEmotionList = document.getElementById('detailEmotionList');

        // ì „ì²´ ê¸ì •(P)/ë¶€ì •(N) ë‹¨ì–´ ì§‘í•© (ìì¹´ë“œ ìœ ì‚¬ë„ ê³„ì‚°ìš©)
        let globalP = new Set(); // ê¸ì • (Positive)
        let globalN = new Set(); // ë¶€ì • (Negative)

        // Character Count
        inputText.addEventListener('input', () => {
            const currentLength = inputText.value.length;
            charCount.textContent = `${currentLength} / 300`;
            if (currentLength > 300) {
                charCount.classList.add('text-red-500');
            } else {
                charCount.classList.remove('text-red-500');
            }
        });

        // Main analysis function - ë¬¸ì¥ë³„ ë¶„ì„
        async function analyzeSentiment() {
            const text = inputText.value.trim();
            const workerUrl = "https://hidden-math-555a.tjdgus1121.workers.dev/";
            const isDetailAnalysis = detailAnalysisCheck.checked;
            
            if (!text) {
                alert('í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”!');
                return;
            }

            if (text.length > 300) {
                alert('í…ìŠ¤íŠ¸ëŠ” 300ìë¥¼ ì´ˆê³¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            // í…ìŠ¤íŠ¸ë¥¼ ë¬¸ì¥ìœ¼ë¡œ ë¶„í•  (ë§ˆì¹¨í‘œ, ëŠë‚Œí‘œ, ë¬¼ìŒí‘œ ê¸°ì¤€)
            const sentences = text.split(/[.!?]+/).map(s => s.trim()).filter(s => s.length > 0);
            
            if (sentences.length === 0) {
                alert('ë¬¸ì¥ì„ ì…ë ¥í•´ì£¼ì„¸ìš”!');
                return;
            }

            // Disable button and show loading
            analyzeBtn.disabled = true;
            analyzeBtn.innerHTML = '<span class="flex items-center justify-center gap-2"><svg class="animate-spin w-5 h-5" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>AI ë¶„ì„ ì¤‘...</span>';

            try {
                // 1ë‹¨ê³„: ëª¨ë“  ë¬¸ì¥ ê°œë³„ ë¶„ì„ (ê°ì„±ì‚¬ì „ êµ¬ì„±ìš©)
                analyzeBtn.innerHTML = `<span class="flex items-center justify-center gap-2"><svg class="animate-spin w-5 h-5" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>ë¬¸ì¥ë³„ ë¶„ì„ ì¤‘... (${sentences.length}ê°œ)</span>`;
                
                // ë¬¸ì¥ë³„ ê²°ê³¼ ì €ì¥
                const sentenceResults = [];
                const sentenceResultsList = document.getElementById('sentenceResultsList');
                sentenceResultsList.innerHTML = '';

                // ê° ë¬¸ì¥ì„ ê°œë³„ì ìœ¼ë¡œ ë¶„ì„
                for (let i = 0; i < sentences.length; i++) {
                    const sentence = sentences[i];
                    
                    // API í˜¸ì¶œ
                    const response = await fetch(workerUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ 
                            text: sentence,
                            detailAnalysis: isDetailAnalysis
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || 'API í˜¸ì¶œ ì‹¤íŒ¨');
                    }

                    const result = await response.json();
                    result.sentenceText = sentence; // ì›ë¬¸ ì €ì¥
                    sentenceResults.push(result);

                    // ë¬¸ì¥ë³„ ê²°ê³¼ ì¦‰ì‹œ í‘œì‹œëŠ” ë‚˜ì¤‘ì— (ê°ì„±ì‚¬ì „ êµ¬ì„± í›„)
                }

                // 2ë‹¨ê³„: ëª¨ë“  ë¬¸ì¥ì˜ morphemesë¥¼ ëª¨ì•„ì„œ ê°ì„±ì‚¬ì „ êµ¬ì„±
                const allMorphemes = [];
                sentenceResults.forEach(result => {
                    if (result.morphemes) {
                        allMorphemes.push(...result.morphemes);
                    }
                });
                
                // ê°€ì§œ wholeTextResult ìƒì„± (displayDictionary í˜¸í™˜ìš©)
                const wholeTextResult = {
                    morphemes: allMorphemes
                };
                
                // ê°ì„±ë‹¨ì–´ì‚¬ì „ í‘œì‹œ (ì „ì—­ ë³€ìˆ˜ ì„¤ì •)
                displayDictionary(wholeTextResult);

                // 3ë‹¨ê³„: ê° ë¬¸ì¥ì˜ ê°ì„± ê°œìˆ˜ë¥¼ ê°ì„±ì‚¬ì „ ê¸°ì¤€ìœ¼ë¡œ ì¬ê³„ì‚°
                sentenceResults.forEach((result, i) => {
                    // ê°ì„±ì‚¬ì „ ê¸°ì¤€ìœ¼ë¡œ ì¬ë¶„ë¥˜ (ì¤‘ë³µ ì œê±°)
                    const posWordsSet = new Set();
                    const neuWordsSet = new Set();
                    const negWordsSet = new Set();
                    
                    if (result.morphemes) {
                        result.morphemes.forEach(m => {
                            // ì „ì—­ ê°ì„±ì‚¬ì „ì— ìˆëŠ” ë‹¨ì–´ë§Œ ë¶„ë¥˜ (ì¤‘ë³µ ìë™ ì œê±°)
                            if (globalP.has(m.word)) {
                                posWordsSet.add(m.word);
                                m.sentiment = 'positive'; // ì¬ë¶„ë¥˜
                            } else if (globalN.has(m.word)) {
                                negWordsSet.add(m.word);
                                m.sentiment = 'negative'; // ì¬ë¶„ë¥˜
                            } else {
                                neuWordsSet.add(m.word);
                                m.sentiment = 'neutral'; // ì¬ë¶„ë¥˜
                            }
                        });
                    }
                    
                    // ê°ì„± ì ìˆ˜ ì—…ë°ì´íŠ¸ (ê³ ìœ  ë‹¨ì–´ ê°œìˆ˜)
                    const posCount = posWordsSet.size;
                    const neuCount = neuWordsSet.size;
                    const negCount = negWordsSet.size;
                    
                    result.sentiment_scores = {
                        positive: posCount,
                        neutral: neuCount,
                        negative: negCount
                    };
                    
                    // ì „ì²´ ê°ì„± ì¬íŒë‹¨
                    if (posCount > negCount) {
                        result.overall_sentiment = 'positive';
                    } else if (negCount > posCount) {
                        result.overall_sentiment = 'negative';
                    } else {
                        result.overall_sentiment = 'neutral';
                    }
                    
                    // ë¬¸ì¥ë³„ ê²°ê³¼ í‘œì‹œ
                    displaySentenceResult(i + 1, result, isDetailAnalysis);
                });

                // ì „ì²´ ê²°ê³¼ í‘œì‹œ
                displayOverallResults(sentenceResults, isDetailAnalysis);
                
                // Show sections
                morphemeSection.classList.add('hidden'); // ì „ì²´ í‚¤ì›Œë“œëŠ” ìˆ¨ê¹€
                vennSection.classList.add('hidden'); // ì „ì²´ ë²¤ë‹¤ì´ì–´ê·¸ë¨ ìˆ¨ê¹€
                dictionarySection.classList.remove('hidden'); // ê°ì„±ë‹¨ì–´ì‚¬ì „ í‘œì‹œ âœ¨
                sentenceResultsSection.classList.remove('hidden'); // ë¬¸ì¥ë³„ ê²°ê³¼ í‘œì‹œ
                resultsSection.classList.remove('hidden'); // ì „ì²´ ìš”ì•½ í‘œì‹œ
                
            } catch (error) {
                console.error('ë¶„ì„ ì˜¤ë¥˜:', error);
                alert(`ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}`);
            } finally {
                // Re-enable button
                analyzeBtn.disabled = false;
                analyzeBtn.innerHTML = '<span class="flex items-center justify-center gap-2"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path></svg>AI í‚¤ì›Œë“œ ë¶„ì„í•˜ê¸°</span>';
            }
        }

        // ê°ì„±ë‹¨ì–´ì‚¬ì „ í‘œì‹œ í•¨ìˆ˜
        function displayDictionary(result) {
            // ë‹¨ì–´ë¥¼ ê°ì„±ë³„ë¡œ ë¶„ë¥˜ (ì›ë³¸ - ì¤‘ë³µ ì œê±° ì „)
            const wordsOriginal = {
                positive: [],
                negative: [],
                neutral: []
            };

            if (result.morphemes) {
                result.morphemes.forEach(m => {
                    if (m.sentiment === 'positive') wordsOriginal.positive.push(m.word);
                    else if (m.sentiment === 'negative') wordsOriginal.negative.push(m.word);
                    else wordsOriginal.neutral.push(m.word);
                });
            }

            // ì „ì—­ ë³€ìˆ˜ ì„¤ì • (ì›ë³¸ - ìì¹´ë“œ ê³„ì‚° ë° ì¬ë¶„ë¥˜ìš©)
            globalP = new Set(wordsOriginal.positive);
            globalN = new Set(wordsOriginal.negative);

            // í™”ë©´ í‘œì‹œìš© (ì¤‘ë³µ ì œê±°)
            const words = {
                positive: removeDuplicates(wordsOriginal.positive),
                negative: removeDuplicates(wordsOriginal.negative),
                neutral: removeDuplicates(wordsOriginal.neutral)
            };

            // ê¸ì • ë‹¨ì–´ í‘œì‹œ
            const positiveWordsList = document.getElementById('positiveWordsList');
            const positiveWordCount = document.getElementById('positiveWordCount');
            if (words.positive.length > 0) {
                positiveWordsList.innerHTML = words.positive.map(word => 
                    `<span class="px-2 py-1 bg-emerald-200 dark:bg-emerald-800 text-emerald-800 dark:text-emerald-200 rounded font-semibold text-xs">${word}</span>`
                ).join('');
                positiveWordCount.textContent = `${words.positive.length}ê°œ`;
            } else {
                positiveWordsList.innerHTML = '<span class="text-xs text-slate-400">ì—†ìŒ</span>';
                positiveWordCount.textContent = '0ê°œ';
            }

            // ì¤‘ë¦½ ë‹¨ì–´ í‘œì‹œ
            const neutralWordsList = document.getElementById('neutralWordsList');
            const neutralWordCount = document.getElementById('neutralWordCount');
            if (words.neutral.length > 0) {
                neutralWordsList.innerHTML = words.neutral.map(word => 
                    `<span class="px-2 py-1 bg-indigo-200 dark:bg-indigo-800 text-indigo-800 dark:text-indigo-200 rounded font-semibold text-xs">${word}</span>`
                ).join('');
                neutralWordCount.textContent = `${words.neutral.length}ê°œ`;
            } else {
                neutralWordsList.innerHTML = '<span class="text-xs text-slate-400">ì—†ìŒ</span>';
                neutralWordCount.textContent = '0ê°œ';
            }

            // ë¶€ì • ë‹¨ì–´ í‘œì‹œ
            const negativeWordsList = document.getElementById('negativeWordsList');
            const negativeWordCount = document.getElementById('negativeWordCount');
            if (words.negative.length > 0) {
                negativeWordsList.innerHTML = words.negative.map(word => 
                    `<span class="px-2 py-1 bg-rose-200 dark:bg-rose-800 text-rose-800 dark:text-rose-200 rounded font-semibold text-xs">${word}</span>`
                ).join('');
                negativeWordCount.textContent = `${words.negative.length}ê°œ`;
            } else {
                negativeWordsList.innerHTML = '<span class="text-xs text-slate-400">ì—†ìŒ</span>';
                negativeWordCount.textContent = '0ê°œ';
            }

            // êµì§‘í•© ë‹¨ì–´ ê³„ì‚° (ê¸ì • âˆ© ë¶€ì •)
            const posSet = new Set(words.positive);
            const negSet = new Set(words.negative);
            const intersection = [...posSet].filter(x => negSet.has(x));
            
            const intersectionWordsList = document.getElementById('intersectionWordsList');
            const intersectionWordCount = document.getElementById('intersectionWordCount');
            if (intersection.length > 0) {
                intersectionWordsList.innerHTML = intersection.map(word => 
                    `<span class="px-2 py-1 bg-violet-200 dark:bg-violet-800 text-violet-800 dark:text-violet-200 rounded font-semibold text-xs">${word}</span>`
                ).join('');
                intersectionWordCount.textContent = `${intersection.length}ê°œ`;
            } else {
                intersectionWordsList.innerHTML = '<span class="text-xs text-slate-400">êµì§‘í•© ì—†ìŒ</span>';
                intersectionWordCount.textContent = '0ê°œ';
            }
        }

        // ì–´ê·¼ ê¸°ë°˜ ì¤‘ë³µ ì œê±° í•¨ìˆ˜
        function removeDuplicates(wordList) {
            // ì™„ì „ ì¤‘ë³µ ì œê±°
            const filtered = [...new Set(wordList)];
            
            // í¬í•¨ ê´€ê³„ ì œê±°: ê¸´ ë‹¨ì–´ê°€ ì§§ì€ ë‹¨ì–´ë¥¼ í¬í•¨í•˜ë©´ ê¸´ ë‹¨ì–´ ì œê±°
            const result = [];
            for (let i = 0; i < filtered.length; i++) {
                let shouldKeep = true;
                const word1 = filtered[i];
                
                for (let j = 0; j < filtered.length; j++) {
                    if (i === j) continue;
                    const word2 = filtered[j];
                    
                    // word1ì´ word2ë¥¼ í¬í•¨í•˜ê³ , word1ì´ ë” ê¸¸ë©´
                    // word1ì„ ì œê±°í•˜ê³  ì§§ì€ word2ë¥¼ ë‚¨ê¹€
                    if (word1.includes(word2) && word1.length > word2.length) {
                        shouldKeep = false;
                        break;
                    }
                }
                
                if (shouldKeep) {
                    result.push(word1);
                }
            }
            
            return result;
        }

        // ë¬¸ì¥ë³„ ê²°ê³¼ í‘œì‹œ í•¨ìˆ˜
        function displaySentenceResult(sentenceNum, result, isDetail) {
            const sentenceResultsList = document.getElementById('sentenceResultsList');
            const isDark = document.documentElement.classList.contains('dark');
            
            // ê°ì„± íŒë‹¨
            const overall = result.overall_sentiment;
            let sentimentClass, sentimentText, sentimentEmoji;
            if (overall === 'positive') {
                sentimentClass = 'bg-emerald-50 dark:bg-emerald-900/20 border-emerald-300 dark:border-emerald-700';
                sentimentText = 'ê¸ì •ì ';
                sentimentEmoji = 'ğŸ˜Š';
            } else if (overall === 'negative') {
                sentimentClass = 'bg-rose-50 dark:bg-rose-900/20 border-rose-300 dark:border-rose-700';
                sentimentText = 'ë¶€ì •ì ';
                sentimentEmoji = 'ğŸ˜¢';
            } else {
                sentimentClass = 'bg-indigo-50 dark:bg-indigo-900/20 border-indigo-300 dark:border-indigo-700';
                sentimentText = 'ì¤‘ë¦½ì ';
                sentimentEmoji = 'ğŸ˜';
            }

            // ìì¹´ë“œ ìœ ì‚¬ë„ ê³„ì‚°: ì •í™•í•œ ë²¤ë‹¤ì´ì–´ê·¸ë¨ ë°©ì‹
            // ë¬¸ì¥ì˜ ì „ì²´ ë‹¨ì–´ A (ê¸ì •+ë¶€ì •+ì¤‘ë¦½ ëª¨ë‘ í¬í•¨)
            const A = new Set(); // ë¬¸ì¥ ì „ì²´ ë‹¨ì–´
            
            if (result.morphemes) {
                result.morphemes.forEach(m => {
                    A.add(m.word);
                });
            }

            // J(A, P) = |A âˆ© P| / |A âˆª P|  (ë¬¸ì¥ ì „ì²´ vs ì „ì²´ ê¸ì •)
            const intersectionAP = new Set([...A].filter(x => globalP.has(x)));
            const unionAP = new Set([...A, ...globalP]);
            const jaccardAP = unionAP.size > 0 ? (intersectionAP.size / unionAP.size * 100) : 0;

            // J(A, N) = |A âˆ© N| / |A âˆª N|  (ë¬¸ì¥ ì „ì²´ vs ì „ì²´ ë¶€ì •)
            const intersectionAN = new Set([...A].filter(x => globalN.has(x)));
            const unionAN = new Set([...A, ...globalN]);
            const jaccardAN = unionAN.size > 0 ? (intersectionAN.size / unionAN.size * 100) : 0;

            // ìì¹´ë“œ ìœ ì‚¬ë„ë¡œ ê°ì„± ì¬íŒë‹¨
            let jaccard, finalSentiment, finalEmoji, finalClass;
            if (jaccardAP > jaccardAN) {
                jaccard = jaccardAP;
                finalSentiment = 'ê¸ì •ì ';
                finalEmoji = 'ğŸ˜Š';
                finalClass = 'bg-emerald-50 dark:bg-emerald-900/20 border-emerald-300 dark:border-emerald-700';
            } else if (jaccardAN > jaccardAP) {
                jaccard = jaccardAN;
                finalSentiment = 'ë¶€ì •ì ';
                finalEmoji = 'ğŸ˜¢';
                finalClass = 'bg-rose-50 dark:bg-rose-900/20 border-rose-300 dark:border-rose-700';
            } else {
                jaccard = Math.max(jaccardAP, jaccardAN);
                finalSentiment = 'ì¤‘ë¦½ì ';
                finalEmoji = 'ğŸ˜';
                finalClass = 'bg-indigo-50 dark:bg-indigo-900/20 border-indigo-300 dark:border-indigo-700';
            }

            const pos = result.sentiment_scores.positive || 0;
            const neu = result.sentiment_scores.neutral || 0;
            const neg = result.sentiment_scores.negative || 0;

            // ë¬¸ì¥ ë‹¨ì–´ì— ìƒ‰ìƒ ì…íˆê¸° (ê¸ì •=ì´ˆë¡, ë¶€ì •=ë¹¨ê°•)
            // globalP, globalNì„ ì§ì ‘ ì‚¬ìš©!
            let coloredSentence = result.sentenceText;
            
            console.log('=== ìƒ‰ìƒ ì ìš© ì‹œì‘ ===');
            console.log('ì›ë³¸ ë¬¸ì¥:', result.sentenceText);
            console.log('globalP:', Array.from(globalP));
            console.log('globalN:', Array.from(globalN));
            
            // globalP, globalNì—ì„œ ë‹¨ì–´ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
            const positiveWords = Array.from(globalP);
            const negativeWords = Array.from(globalN);
            
            console.log('ê¸ì • ë‹¨ì–´:', positiveWords);
            console.log('ë¶€ì • ë‹¨ì–´:', negativeWords);
            
            // ê¸´ ë‹¨ì–´ë¶€í„° ì²˜ë¦¬
            positiveWords.sort((a, b) => b.length - a.length);
            negativeWords.sort((a, b) => b.length - a.length);
            
            // ê¸ì • ë‹¨ì–´ ìƒ‰ìƒ ì ìš©
            positiveWords.forEach(word => {
                let stem = word.endsWith('ë‹¤') ? word.slice(0, -1) : word;
                const pattern = stem.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '[ê°€-í£]*';
                const regex = new RegExp(pattern, 'g');
                
                coloredSentence = coloredSentence.replace(regex, (matched) => {
                    console.log(`ê¸ì • ë§¤ì¹­: ${matched}`);
                    if (matched.includes('<') || matched.includes('>')) {
                        return matched;
                    }
                    return `<span class="text-emerald-600 dark:text-emerald-400 font-bold">${matched}</span>`;
                });
            });
            
            // ë¶€ì • ë‹¨ì–´ ìƒ‰ìƒ ì ìš©
            negativeWords.forEach(word => {
                let stem = word.endsWith('ë‹¤') ? word.slice(0, -1) : word;
                const pattern = stem.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '[ê°€-í£]*';
                const regex = new RegExp(pattern, 'g');
                
                coloredSentence = coloredSentence.replace(regex, (matched) => {
                    console.log(`ë¶€ì • ë§¤ì¹­: ${matched}`);
                    if (matched.includes('<') || matched.includes('>')) {
                        return matched;
                    }
                    return `<span class="text-rose-600 dark:text-rose-400 font-bold">${matched}</span>`;
                });
            });
            
            console.log('ìµœì¢… ê²°ê³¼:', coloredSentence);
            console.log('=== ìƒ‰ìƒ ì ìš© ë ===');

            const sentenceCard = document.createElement('div');
            sentenceCard.className = `p-6 border-2 rounded-xl ${finalClass}`;
            sentenceCard.innerHTML = `
                <div class="flex items-start justify-between mb-3">
                    <div class="flex items-center gap-2">
                        <span class="text-base font-bold text-slate-600 dark:text-slate-300">ë¬¸ì¥ ${sentenceNum}</span>
                        <span class="text-2xl">${finalEmoji}</span>
                        <span class="font-semibold text-base text-slate-700 dark:text-slate-200">${finalSentiment}</span>
                    </div>
                    <div class="text-right">
                        <div class="text-xs text-slate-500 dark:text-slate-400">ìì¹´ë“œ ìœ ì‚¬ë„</div>
                        <div class="text-lg font-bold text-violet-600 dark:text-violet-400">${jaccard.toFixed(1)}%</div>
                        <div class="text-xs text-slate-500 dark:text-slate-400 mt-1">
                            J(A,P): ${jaccardAP.toFixed(1)}% / J(A,N): ${jaccardAN.toFixed(1)}%
                        </div>
                    </div>
                </div>
                <div class="text-base text-slate-700 dark:text-slate-300 mb-4 p-3 bg-white dark:bg-slate-800 rounded-lg">
                    ${coloredSentence}
                </div>
                
                <!-- ìì¹´ë“œ ìœ ì‚¬ë„ ê³„ì‚° ê³¼ì • -->
                <div class="mb-4 p-3 bg-slate-50 dark:bg-slate-900/50 rounded-lg border border-slate-200 dark:border-slate-700">
                    <div class="text-sm font-semibold text-slate-700 dark:text-slate-300 mb-2">ğŸ“Š ìì¹´ë“œ ìœ ì‚¬ë„ ê³„ì‚° ê³¼ì •</div>
                    
                    <!-- ë¬¸ì¥ ë‹¨ì–´ì§‘í•© A -->
                    <div class="text-xs text-slate-600 dark:text-slate-400 mb-2 p-2 bg-blue-50 dark:bg-blue-900/20 rounded">
                        <div class="font-semibold text-blue-600 dark:text-blue-400 mb-1">ë¬¸ì¥ ë‹¨ì–´ì§‘í•© A</div>
                        <div class="ml-2">
                            A = {${[...A].slice(0, 15).join(', ')}}${A.size > 15 ? '...' : ''}} = ${A.size}ê°œ
                        </div>
                    </div>
                    
                    <!-- J(A, P) ê³„ì‚° -->
                    <div class="text-xs text-slate-600 dark:text-slate-400 mb-2">
                        <div class="font-semibold text-emerald-600 dark:text-emerald-400 mb-1">J(A, P) = ê¸ì • ìœ ì‚¬ë„</div>
                        <div class="ml-2">
                            A âˆ© P = {${[...intersectionAP].join(', ')}} = ${intersectionAP.size}ê°œ<br>
                            A âˆª P = {${[...unionAP].slice(0, 10).join(', ')}}${unionAP.size > 10 ? '...' : ''} = ${unionAP.size}ê°œ<br>
                            <span class="font-semibold">J(A,P) = ${intersectionAP.size}/${unionAP.size} = ${jaccardAP.toFixed(1)}%</span>
                        </div>
                    </div>
                    
                    <!-- J(A, N) ê³„ì‚° -->
                    <div class="text-xs text-slate-600 dark:text-slate-400">
                        <div class="font-semibold text-rose-600 dark:text-rose-400 mb-1">J(A, N) = ë¶€ì • ìœ ì‚¬ë„</div>
                        <div class="ml-2">
                            A âˆ© N = {${[...intersectionAN].join(', ')}} = ${intersectionAN.size}ê°œ<br>
                            A âˆª N = {${[...unionAN].slice(0, 10).join(', ')}}${unionAN.size > 10 ? '...' : ''} = ${unionAN.size}ê°œ<br>
                            <span class="font-semibold">J(A,N) = ${intersectionAN.size}/${unionAN.size} = ${jaccardAN.toFixed(1)}%</span>
                        </div>
                    </div>
                    
                    <!-- ìµœì¢… íŒë‹¨ -->
                    <div class="mt-2 pt-2 border-t border-slate-200 dark:border-slate-700 text-xs">
                        <span class="font-semibold text-violet-600 dark:text-violet-400">
                            ìµœì¢…: ${jaccardAP.toFixed(1)}% ${jaccardAP > jaccardAN ? '>' : jaccardAP < jaccardAN ? '<' : '='} ${jaccardAN.toFixed(1)}% â†’ ${finalSentiment}
                        </span>
                    </div>
                </div>
                
                <div class="grid grid-cols-3 gap-3 text-sm">
                    <div class="text-center p-2 bg-emerald-100 dark:bg-emerald-900/30 rounded">
                        <div class="font-semibold text-emerald-700 dark:text-emerald-300">ê¸ì •</div>
                        <div class="text-2xl font-bold text-emerald-600 dark:text-emerald-400">${pos}</div>
                    </div>
                    <div class="text-center p-2 bg-indigo-100 dark:bg-indigo-900/30 rounded">
                        <div class="font-semibold text-indigo-700 dark:text-indigo-300">ì¤‘ë¦½</div>
                        <div class="text-2xl font-bold text-indigo-600 dark:text-indigo-400">${neu}</div>
                    </div>
                    <div class="text-center p-2 bg-rose-100 dark:bg-rose-900/30 rounded">
                        <div class="font-semibold text-rose-700 dark:text-rose-300">ë¶€ì •</div>
                        <div class="text-2xl font-bold text-rose-600 dark:text-rose-400">${neg}</div>
                    </div>
                </div>
            `;
            
            sentenceResultsList.appendChild(sentenceCard);
        }

        // ì „ì²´ ìš”ì•½ í‘œì‹œ í•¨ìˆ˜
        function displayOverallResults(sentenceResults, isDetail) {
            const finalSentiment = document.getElementById('finalSentiment');
            
            // ì „ì²´ ê¸ì •/ë¶€ì • ì¹´ìš´íŠ¸
            let totalPos = 0, totalNeu = 0, totalNeg = 0;
            let posCount = 0, negCount = 0, neuCount = 0;
            
            sentenceResults.forEach(result => {
                totalPos += result.sentiment_scores.positive || 0;
                totalNeu += result.sentiment_scores.neutral || 0;
                totalNeg += result.sentiment_scores.negative || 0;
                
                if (result.overall_sentiment === 'positive') posCount++;
                else if (result.overall_sentiment === 'negative') negCount++;
                else neuCount++;
            });

            const totalSentences = sentenceResults.length;
            
            // ì „ì²´ ê°ì„± íŒë‹¨
            let overallText, overallClass;
            if (posCount > negCount) {
                overallClass = 'bg-gradient-to-r from-emerald-100 to-emerald-200 dark:from-emerald-900/30 dark:to-emerald-800/30 text-emerald-700 dark:text-emerald-300';
                overallText = `ğŸ˜Š ì „ì²´ì ìœ¼ë¡œ ê¸ì •ì ì…ë‹ˆë‹¤! (ê¸ì • ${posCount}/${totalSentences} ë¬¸ì¥)`;
            } else if (negCount > posCount) {
                overallClass = 'bg-gradient-to-r from-rose-100 to-rose-200 dark:from-rose-900/30 dark:to-rose-800/30 text-rose-700 dark:text-rose-300';
                overallText = `ğŸ˜¢ ì „ì²´ì ìœ¼ë¡œ ë¶€ì •ì ì…ë‹ˆë‹¤! (ë¶€ì • ${negCount}/${totalSentences} ë¬¸ì¥)`;
            } else {
                overallClass = 'bg-gradient-to-r from-indigo-100 to-indigo-200 dark:from-indigo-900/30 dark:to-indigo-800/30 text-indigo-700 dark:text-indigo-300';
                overallText = `ğŸ˜ ì „ì²´ì ìœ¼ë¡œ ì¤‘ë¦½ì ì…ë‹ˆë‹¤! (ì¤‘ë¦½ ${neuCount}/${totalSentences} ë¬¸ì¥)`;
            }

            finalSentiment.className = `p-4 rounded-xl text-center font-semibold text-lg mb-4 ${overallClass}`;
            finalSentiment.textContent = overallText;

            // ì „ì²´ ê¸ì • vs ì „ì²´ ë¶€ì • ìì¹´ë“œ ìœ ì‚¬ë„
            const allPosIntersection = new Set([...globalP].filter(x => globalN.has(x)));
            const allPosUnion = new Set([...globalP, ...globalN]);
            const overallJaccard = allPosUnion.size > 0 ? (allPosIntersection.size / allPosUnion.size * 100) : 0;

            document.getElementById('formulaDisplay').innerHTML = `
                <div class="space-y-2">
                    <div class="text-xl font-bold text-slate-700 dark:text-slate-300">ì „ì²´ í†µê³„</div>
                    <div class="grid grid-cols-3 gap-3 mt-3">
                        <div class="p-3 bg-emerald-50 dark:bg-emerald-900/20 rounded">
                            <div class="text-sm text-emerald-600 dark:text-emerald-400">ê¸ì •</div>
                            <div class="text-3xl font-bold text-emerald-600 dark:text-emerald-400">${totalPos}</div>
                        </div>
                        <div class="p-3 bg-indigo-50 dark:bg-indigo-900/20 rounded">
                            <div class="text-sm text-indigo-600 dark:text-indigo-400">ì¤‘ë¦½</div>
                            <div class="text-3xl font-bold text-indigo-600 dark:text-indigo-400">${totalNeu}</div>
                        </div>
                        <div class="p-3 bg-rose-50 dark:bg-rose-900/20 rounded">
                            <div class="text-sm text-rose-600 dark:text-rose-400">ë¶€ì •</div>
                            <div class="text-3xl font-bold text-rose-600 dark:text-rose-400">${totalNeg}</div>
                        </div>
                    </div>
                    <div class="mt-4 p-4 bg-violet-50 dark:bg-violet-900/20 rounded-lg">
                        <div class="text-base text-slate-600 dark:text-slate-400 mb-2">
                            J(P, N) = |P âˆ© N| / |P âˆª N|
                        </div>
                        <div class="text-base">
                            = ${allPosIntersection.size} / ${allPosUnion.size} = 
                            <strong class="text-violet-600 dark:text-violet-400 text-2xl">${overallJaccard.toFixed(1)}%</strong>
                        </div>
                        <div class="text-xs text-slate-500 dark:text-slate-400 mt-2">
                            ì „ì²´ ê¸ì •ë‹¨ì–´ P(${globalP.size}ê°œ)ì™€ ë¶€ì •ë‹¨ì–´ N(${globalN.size}ê°œ)ì˜ ìœ ì‚¬ë„
                        </div>
                    </div>
                </div>
            `;
        }

        // Display morphemes
        function displayMorphemes(morphemes, isDetail) {
            // ê°•ë ¥í•œ ì¤‘ë³µ ì œê±°: 
            // 1. ì™„ì „íˆ ê°™ì€ ë‹¨ì–´ ì œê±°
            // 2. í¬í•¨ ê´€ê³„: "ê°ë™"ê³¼ "ê°ë™ë°›ë‹¤" â†’ ì§§ì€ "ê°ë™"ë§Œ ë‚¨ê¹€
            const uniqueMorphemes = [];
            const seenWords = new Set();
            
            // ë¨¼ì € ì™„ì „ ì¤‘ë³µ ì œê±°
            const filtered = [];
            morphemes.forEach(m => {
                if (!seenWords.has(m.word)) {
                    seenWords.add(m.word);
                    filtered.push(m);
                }
            });
            
            // í¬í•¨ ê´€ê³„ ì œê±°: ê¸´ ë‹¨ì–´ê°€ ì§§ì€ ë‹¨ì–´ë¥¼ í¬í•¨í•˜ë©´ ê¸´ ë‹¨ì–´ ì œê±°
            for (let i = 0; i < filtered.length; i++) {
                let shouldKeep = true;
                const word1 = filtered[i].word;
                
                for (let j = 0; j < filtered.length; j++) {
                    if (i === j) continue;
                    const word2 = filtered[j].word;
                    
                    // word1ì´ word2ë¥¼ í¬í•¨í•˜ê³ , word1ì´ ë” ê¸¸ë©´
                    // word1ì„ ì œê±°í•˜ê³  ì§§ì€ word2ë¥¼ ë‚¨ê¹€
                    if (word1.includes(word2) && word1.length > word2.length) {
                        shouldKeep = false;
                        break;
                    }
                }
                
                if (shouldKeep) {
                    uniqueMorphemes.push(filtered[i]);
                }
            }
            
            let html = '<div class="flex flex-wrap gap-2 items-center">';
            
            uniqueMorphemes.forEach(m => {
                const sentimentClass = `morpheme-${m.sentiment}`;
                let detailBadge = '';
                if (isDetail && m.specific_emotion && m.specific_emotion !== 'ì¤‘ë¦½') {
                    // ê°ì •ì— ë”°ë¥¸ ìƒ‰ìƒ (ê°„ë‹¨íˆ)
                    const colorMap = {
                        'ê¸°ì¨': 'bg-yellow-100 text-yellow-800',
                        'ìŠ¬í””': 'bg-blue-100 text-blue-800',
                        'ë¶„ë…¸': 'bg-red-100 text-red-800',
                        'ë†€ëŒ': 'bg-purple-100 text-purple-800',
                        'ë‘ë ¤ì›€': 'bg-gray-100 text-gray-800',
                        'í˜ì˜¤': 'bg-green-100 text-green-800'
                    };
                    const badgeClass = colorMap[m.specific_emotion] || 'bg-gray-100 text-gray-600';
                    detailBadge = `<span class="emotion-badge ${badgeClass}">${m.specific_emotion}</span>`;
                }
                
                html += `<div class="inline-flex items-center bg-white dark:bg-slate-700 border border-slate-200 dark:border-slate-600 rounded px-2 py-1">
                            <span class="${sentimentClass} mr-1" title="${m.pos}">${m.word}</span>
                            ${detailBadge}
                         </div>`;
            });
            
            html += '</div>';
            morphemeDisplay.innerHTML = html;
        }

        // Display Venn Diagram with Words
        function displayVennDiagram(scores, morphemes) {
            const svg = document.getElementById('vennDiagram');
            const isDark = document.documentElement.classList.contains('dark');
            const textColor = isDark ? '#e2e8f0' : '#1e293b';
            const subTextColor = isDark ? '#94a3b8' : '#64748b';

            // 1. ë‹¨ì–´ ë¶„ë¥˜ ë° ì¤‘ë³µ ì œê±°
            const words = {
                positive: [],
                negative: [],
                neutral: []
            };

            if (morphemes) {
                morphemes.forEach(m => {
                    if (m.sentiment === 'positive') words.positive.push(m.word);
                    else if (m.sentiment === 'negative') words.negative.push(m.word);
                    else words.neutral.push(m.word);
                });
                // ì¤‘ë³µ ì œê±°
                words.positive = [...new Set(words.positive)];
                words.negative = [...new Set(words.negative)];
                words.neutral = [...new Set(words.neutral)];
            }

            // 2. ë²¤ë‹¤ì´ì–´ê·¸ë¨ êµ¬ì¡°
            const leftCx = 150, leftCy = 160, rightCx = 350, rightCy = 160, radius = 100;
            
            let svgContent = `
                <!-- ë°°ê²½ ì›ë“¤ -->
                <circle cx="${leftCx}" cy="${leftCy}" r="${radius}" fill="#10b981" opacity="0.15" stroke="#10b981" stroke-width="3"/>
                <circle cx="${rightCx}" cy="${rightCy}" r="${radius}" fill="#ef4444" opacity="0.15" stroke="#ef4444" stroke-width="3"/>
                
                <!-- êµì§‘í•© ì˜ì—­ -->
                <ellipse cx="250" cy="160" rx="65" ry="95" fill="#6366f1" opacity="0.25" stroke="#6366f1" stroke-width="2" stroke-dasharray="5,5"/>
                
                <!-- ìƒë‹¨ ë ˆì´ë¸” -->
                <text x="${leftCx}" y="30" font-size="16" fill="${textColor}" font-weight="bold" text-anchor="middle">ê¸ì • ì§‘í•©</text>
                <text x="250" y="30" font-size="16" fill="${textColor}" font-weight="bold" text-anchor="middle">ì¤‘ë¦½ (êµì§‘í•©)</text>
                <text x="${rightCx}" y="30" font-size="16" fill="${textColor}" font-weight="bold" text-anchor="middle">ë¶€ì • ì§‘í•©</text>
                
                <!-- í•˜ë‹¨ ê°œìˆ˜ -->
                <text x="${leftCx}" y="290" font-size="14" fill="${subTextColor}" text-anchor="middle">${words.positive.length}ê°œ</text>
                <text x="250" y="290" font-size="14" fill="${subTextColor}" text-anchor="middle">${words.neutral.length}ê°œ</text>
                <text x="${rightCx}" y="290" font-size="14" fill="${subTextColor}" text-anchor="middle">${words.negative.length}ê°œ</text>
            `;

            // 3. ë‹¨ì–´ ë°°ì¹˜ í•¨ìˆ˜ (ì¶©ëŒ ë°©ì§€)
            function placeWordsInGrid(wordList, region, color) {
                if (wordList.length === 0) return '';
                
                // ê¸€ì í¬ê¸° ìë™ ì¡°ì ˆ
                const baseSize = wordList.length > 10 ? 11 : wordList.length > 5 ? 13 : 14;
                
                let result = '';
                let { startX, endX, startY, endY, rows, cols } = region;
                
                // ê²©ì ì„¤ì •
                const cellWidth = (endX - startX) / cols;
                const cellHeight = (endY - startY) / rows;
                
                wordList.forEach((word, idx) => {
                    const row = Math.floor(idx / cols);
                    const col = idx % cols;
                    
                    if (row >= rows) return; // ì˜ì—­ ì´ˆê³¼ ì‹œ ë¬´ì‹œ
                    
                    const x = startX + col * cellWidth + cellWidth / 2;
                    const y = startY + row * cellHeight + cellHeight / 2;
                    
                    // í˜¸ë²„ íš¨ê³¼ì™€ ê·¸ë¦¼ì ì¶”ê°€
                    result += `
                        <text 
                            x="${x}" 
                            y="${y}" 
                            font-size="${baseSize}" 
                            fill="${color}" 
                            text-anchor="middle" 
                            dominant-baseline="middle"
                            font-weight="600" 
                            class="word-hover"
                            style="text-shadow: 0 1px 3px rgba(255,255,255,0.9); cursor: pointer; transition: all 0.2s;"
                            onmouseover="this.setAttribute('font-size', '${baseSize + 3}'); this.setAttribute('font-weight', '700');"
                            onmouseout="this.setAttribute('font-size', '${baseSize}'); this.setAttribute('font-weight', '600');"
                        >${word}</text>`;
                });
                
                return result;
            }

            // 4. ì˜ì—­ë³„ ë‹¨ì–´ ë°°ì¹˜
            // ê¸ì • ì˜ì—­ (ì™¼ìª½)
            const positiveRegion = {
                startX: 60,
                endX: 180,
                startY: 80,
                endY: 240,
                rows: 5,
                cols: 2
            };
            svgContent += placeWordsInGrid(words.positive, positiveRegion, '#059669');

            // ì¤‘ë¦½ ì˜ì—­ (ê°€ìš´ë° êµì§‘í•©)
            const neutralRegion = {
                startX: 210,
                endX: 290,
                startY: 75,
                endY: 245,
                rows: 6,
                cols: 2
            };
            svgContent += placeWordsInGrid(words.neutral, neutralRegion, '#4f46e5');

            // ë¶€ì • ì˜ì—­ (ì˜¤ë¥¸ìª½)
            const negativeRegion = {
                startX: 320,
                endX: 440,
                startY: 80,
                endY: 240,
                rows: 5,
                cols: 2
            };
            svgContent += placeWordsInGrid(words.negative, negativeRegion, '#dc2626');

            svg.innerHTML = svgContent;
            
            // í•˜ë‹¨ ê°œìˆ˜ ì—…ë°ì´íŠ¸
            document.getElementById('positiveCount').textContent = words.positive.length;
            document.getElementById('neutralCount').textContent = words.neutral.length;
            document.getElementById('negativeCount').textContent = words.negative.length;
        }

        // Dark mode toggle
        darkModeToggle.addEventListener('click', () => {
            document.documentElement.classList.toggle('dark');
            localStorage.setItem('darkMode', document.documentElement.classList.contains('dark'));
        });

        // Load dark mode preference
        if (localStorage.getItem('darkMode') === 'true') {
            document.documentElement.classList.add('dark');
        }

        // Event listeners
        analyzeBtn.addEventListener('click', analyzeSentiment);
        inputText.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && e.ctrlKey) {
                analyzeSentiment();
            }
        });
    </script>
</body>
</html>